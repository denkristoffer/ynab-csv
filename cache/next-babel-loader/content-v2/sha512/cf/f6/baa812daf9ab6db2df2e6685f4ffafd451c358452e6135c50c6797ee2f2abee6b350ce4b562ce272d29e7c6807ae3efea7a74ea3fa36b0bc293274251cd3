{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { useCallback, useMemo, useState } from \"react\";\nimport { parse } from \"papaparse\";\nimport dayjs from \"dayjs\";\nimport customParseFormat from \"dayjs/plugin/customParseFormat\";\ndayjs.extend(customParseFormat);\nimport { useAsyncState } from \"../lib/hooks\";\nimport Dropzone from \"../components/dropzone\";\nimport Table from \"../components/table\";\nimport Td from \"../components/tableCell\";\nimport DownloadButton from \"../components/downloadButton\";\n\nconst downloadUrlAsFile = (objectUrl, filename) => {\n  return new Promise((resolve, _reject) => {\n    const a = document.createElement(\"a\");\n    a.download = filename;\n    a.href = objectUrl;\n    document.body.append(a);\n    a.click();\n    a.remove();\n    resolve();\n  });\n};\n\nconst downloadStringAsFile = async (string, filename) => {\n  const file = new Blob([string], {\n    type: \"text/csv;charset=utf-8;\"\n  });\n  const url = URL.createObjectURL(file);\n  await downloadUrlAsFile(url, filename);\n  URL.revokeObjectURL(url);\n};\n\nconst Th = props => __jsx(Td, _extends({\n  className: \"text-left font-semibold px-0\",\n  element: \"th\"\n}, props));\n\nconst isDkb = text => {\n  const lines = text.split(\"\\n\");\n  const regexp = new RegExp(/\"Kontonummer:\";\"/);\n  const matches = regexp.exec(lines[0]);\n  return matches !== null;\n};\n/**\n * Discards the lines with additional info that DKB adds to CSV exports\n *\n * @param string\n */\n\n\nconst cleanDkb = text => {\n  const lines = text.split(\"\\n\");\n  const wantedLines = lines.slice(6);\n  return wantedLines.join(\"\\n\");\n};\n\nconst SAMPLE_DATA_ROWS = 10;\nexport default function IndexPage() {\n  const {\n    0: isLoading,\n    1: setIsLoading\n  } = useState(false);\n  const [data, setData] = useAsyncState([]);\n  const {\n    0: csvColumns,\n    1: setCsvColumns\n  } = useState([]);\n  const {\n    0: csvColumnMap,\n    1: setCsvColumnMap\n  } = useState({\n    Date: \"\",\n    Payee: \"\",\n    Memo: \"\",\n    Outflow: \"\",\n    Inflow: \"\"\n  });\n  const isTransformed = useMemo(() => {\n    return Object.values(csvColumnMap).some(value => value !== \"\");\n  }, [csvColumnMap]);\n  const parseCsv = useCallback(async (file, preview = true) => {\n    setCsvColumns([]);\n    setCsvColumnMap({\n      Date: \"\",\n      Payee: \"\",\n      Memo: \"\",\n      Outflow: \"\",\n      Inflow: \"\"\n    });\n    setData([]);\n    let text = await file.text();\n\n    if (isDkb(text)) {\n      text = cleanDkb(text);\n    }\n\n    parse(text, {\n      header: true,\n      preview: preview ? SAMPLE_DATA_ROWS : undefined,\n      skipEmptyLines: \"greedy\",\n      step: ({\n        data: row,\n        errors\n      }, parser) => {\n        if (errors.length > 0) {\n          console.error(errors);\n          parser.abort();\n        }\n\n        setData(data.current.concat(row));\n      },\n      transform: value => {\n        return value.trim();\n      },\n      transformHeader: header => {\n        if (header.trim().length === 0) {\n          header = \"Unnamed column\";\n        }\n\n        if (csvColumns.includes(header)) {\n          let newHeader = header;\n          let counter = 0;\n\n          while (csvColumns.includes(newHeader)) {\n            counter = counter + 1;\n            newHeader = `${header} (${counter})`;\n          }\n\n          header = newHeader;\n        }\n\n        setCsvColumns(existingColumns => [...existingColumns, header]);\n        return header;\n      }\n    });\n  }, [csvColumns, data, setData]);\n  const transformRow = useCallback(row => {\n    return Object.keys(csvColumnMap).map(key => {\n      const column = key;\n      const columnInData = csvColumnMap[column];\n      let cell = row[columnInData];\n\n      if (cell) {\n        switch (column) {\n          case \"Date\":\n            {\n              cell = dayjs(cell, [\"DD-MM-YYYY\", \"MM-DD-YYYY\", \"YYYY-MM-DD\"]).format(\"YYYY-MM-DD\");\n              break;\n            }\n\n          case \"Outflow\":\n            {\n              if (csvColumnMap[\"Outflow\"] === csvColumnMap[\"Inflow\"]) {\n                cell = cell.startsWith(\"-\") ? cell.slice(1) : \"\";\n              }\n\n              break;\n            }\n\n          case \"Inflow\":\n            {\n              if (csvColumnMap[\"Outflow\"] === csvColumnMap[\"Inflow\"]) {\n                cell = cell.startsWith(\"-\") ? \"\" : cell;\n              }\n\n              break;\n            }\n\n          default:\n            break;\n        }\n\n        return cell;\n      }\n\n      return \"\";\n    });\n  }, [csvColumnMap]);\n  const previewData = useMemo(() => {\n    const rows = data.current.length > 10 ? data.current.slice(0, 10) : data.current;\n    return rows.map(row => transformRow(row));\n  }, [data, transformRow]);\n  const buildCsvFromRows = useCallback(dataToBuild => {\n    const columns = Object.keys(csvColumnMap);\n    const rows = dataToBuild.map(row => {\n      return transformRow(row).map(cell => {\n        // Escape any existing quotes in the cell\n        const cellWithEscapedQuotes = cell.replace(/\"/g, '\"\"');\n        return `\"${cellWithEscapedQuotes}\"`;\n      });\n    });\n    const string = columns.map(column => `\"${column}\"`).join(\",\") + \"\\n\" + rows.join(\"\\n\");\n    return string;\n  }, [csvColumnMap, transformRow]);\n  const hasData = data.current.length > 0;\n  const ynabColumns = Object.keys(csvColumnMap);\n  return __jsx(\"div\", {\n    className: \"container h-full w-full bg-white max-w-none dark:bg-gray-800\"\n  }, __jsx(Dropzone, {\n    hasFile: hasData,\n    onDrop: parseCsv\n  }, hasData ? __jsx(\"div\", {\n    className: \"flex flex-col h-full\"\n  }, isTransformed ? __jsx(DownloadButton, {\n    isActive: isLoading,\n    onClick: () => {\n      setIsLoading(true);\n      const csv = buildCsvFromRows(data.current);\n      setIsLoading(false);\n      void downloadStringAsFile(csv, \"ynab-data.csv\");\n    }\n  }) : null, __jsx(Table, {\n    data: isTransformed ? previewData : [],\n    header: __jsx(\"thead\", null, __jsx(\"tr\", {\n      className: \"bg-gray-100 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-600\"\n    }, ynabColumns.map(column => {\n      return __jsx(Th, {\n        key: column\n      }, __jsx(\"div\", null, column), __jsx(\"div\", null, __jsx(\"select\", {\n        className: \"w-full\",\n        onChange: event => {\n          const value = event.target.value || \"\";\n          setCsvColumnMap(current => {\n            return _objectSpread(_objectSpread({}, current), {}, {\n              [column]: value\n            });\n          });\n        }\n      }, __jsx(\"option\", {\n        value: \"\"\n      }, \"Select column\\u2026\"), csvColumns.map(column => {\n        return __jsx(\"option\", {\n          key: column,\n          value: column\n        }, column);\n      }))));\n    })))\n  }), __jsx(\"div\", {\n    className: \"flex items-center h-full w-full\"\n  }, __jsx(\"p\", {\n    className: \"text-center w-full dark:text-white\"\n  }, isTransformed ? `Previewing the first ${SAMPLE_DATA_ROWS} rows.` : \"Select columns to preview data.\"))) : null));\n}","map":null,"metadata":{},"sourceType":"module"}